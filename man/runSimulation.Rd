\name{runSimulation}
\docType{methods}
\alias{runSimulation}
\alias{runSimulation-methods}
\alias{runSimulation,ANY,ANY,ANY,missing-method}
\alias{runSimulation,data.frame,missing,missing,SimControl-method}
\alias{runSimulation,data.frame,missing,numeric,SimControl-method}
\alias{runSimulation,data.frame,SampleSetup,missing,SimControl-method}
\alias{runSimulation,data.frame,VirtualSampleControl,missing,SimControl-method}
\alias{runSimulation,VirtualDataControl,missing,numeric,SimControl-method}
\alias{runSimulation,VirtualDataControl,VirtualSampleControl,numeric,SimControl-method}

\title{Run a simulation experiment}
\description{
Generic function for running a simulation experiment.
}
\usage{
runSimulation(x, setup, nrep, control, contControl = NULL, 
              NAControl = NULL, design = character(), fun, 
              ..., seed, ncores = 1, cl = NULL)
}
\arguments{
  \item{x}{a \code{data.frame} (for design-based simulation or simulation based 
    on real data) or a control object for data generation inheriting from 
    \code{"VirtualDataControl"} (for model-based simulation or mixed simulation 
    designs).}
  \item{setup}{an object of class \code{"SampleSetup"}, containing previously 
    set up samples, or a control class for setting up samples inheriting 
    from \code{"VirtualSampleControl"}.}
  \item{nrep}{a non-negative integer giving the number of repetitions of the 
    simulation experiment (for model-based simulation, mixed simulation designs 
    or simulation based on real data).}
  \item{control}{a control object of class \code{"SimControl"}}    
  \item{contControl}{an optional object of a class inheriting from 
    \code{"VirtualContControl"}, controlling contamination in the simulation 
    experiment.}
  \item{NAControl}{an optional object of a class inheriting from 
    \code{"VirtualNAControl"}, controlling the insertion of missing values in 
    the simulation experiment.}
  \item{design}{a character vector specifying variables (columns) to be used 
    for splitting the data into domains.  The simulations, including 
    contamination and the insertion of missing values, are then performed on 
    every domain.}
  \item{fun}{a function to be applied in each simulation run.}
  \item{\dots}{additional arguments to be passed to \code{fun}.}
  \item{seed}{an integer to be used as initial seed of the random number 
    generator (see \code{\link{.Random.seed}}).  In case of parallel computing, 
    random number streams are used and the seed is set via 
    \code{\link[parallel]{clusterSetRNGStream}}.  If not supplied, the seed 
    will be based on the current date and time.}
  \item{ncores}{a positive integer giving the number of processor cores to be 
    used for parallel computing (the default is 1 for no parallelization).  If 
    this is set to \code{NA}, all available processor cores are used.}
  \item{cl}{a \pkg{parallel} cluster for parallel computing as generated by 
    \code{\link[parallel]{makeCluster}}.  If supplied, this is preferred over 
    \code{ncores}.}
}
\details{
  For convenience, the slots of \code{control} may be supplied as arguments.
  
  There are some requirements for slot \code{fun} of the control object 
  \code{control}.  Most importantly, the function must return a numeric 
  vector.  A \code{data.frame} is passed to \code{fun} in every simulation 
  run.  The corresponding argument must be called \code{x}.  If comparisons 
  with the original data need to be made, e.g., for evaluating the quality of 
  imputation methods, the function should have an argument called \code{orig}.  
  If different domains are used in the simulation, the indices of the current 
  domain can be passed to the function via an argument called \code{domain}.

  In every simulation run, \code{fun} is evaluated using \code{try}.  Hence 
  no results are lost if computations fail in any of the simulation runs.
}
\value{
  An object of class \code{"SimResults"}.
}
\section{Methods}{
  \describe{
  \item{\code{x = "ANY", setup = "ANY", nrep = "ANY", control = "missing"}}{
    convenience wrapper that allows the slots of \code{control} to be supplied 
    as arguments}
  \item{\code{x = "data.frame", setup = "missing", nrep = "missing", 
    control = "SimControl"}}{run a simulation experiment based on real data 
    without repetitions (e.g., for sensitiviy analysis).}
  \item{\code{x = "data.frame", setup = "missing", nrep = "numeric", 
    control = "SimControl"}}{run a simulation experiment based on real data 
    with repetitions.}
  \item{\code{x = "data.frame", setup = "SampleSetup", nrep = "missing", 
    control = "SimControl"}}{run a design-based simulation experiment with 
    previously set up samples.}
  \item{\code{x = "data.frame", setup = "VirtualSampleControl", 
    nrep = "missing", control = "SimControl"}}{run a design-based simulation 
    experiment.}
  \item{\code{x = "VirtualDataControl", setup = "missing", nrep = "numeric", 
    control = "SimControl"}}{run a model-based simulation experiment.}
  \item{\code{x = "VirtualDataControl", setup = "VirtualSampleControl", 
    nrep = "numeric", control = "SimControl"}}{run a simulation experiment 
    using a mixed simulation design.}
  }
}
\author{Andreas Alfons}
\references{
Alfons, A., Templ, M. and Filzmoser, P. (2010) An Object-Oriented Framework for 
Statistical Simulation: The \R Package \pkg{simFrame}. \emph{Journal of 
Statistical Software}, \bold{37}(3), 1--36. URL 
\url{http://www.jstatsoft.org/v37/i03/}.
}
\seealso{
  \code{"\linkS4class{SimControl}"}, \code{"\linkS4class{SimResults}"}, 
  \code{\link{simPlot}}
}
\examples{
#### design-based simulation
data("eusilcP")  # load data

## control objects for sampling and contamination
sc <- SampleControl(size = 500, k = 50, seed = 12345)
cc <- CARContControl(target = "eqIncome", epsilon = 0.02, 
    fun = function(x) x * 10)

## function for simulation runs
sim <- function(x) {
    c(mean = mean(x$eqIncome), trimmed = mean(x$eqIncome, 0.02))
}

## run simulation and explore results
results <- runSimulation(eusilcP, sc, contControl = cc, 
    fun = sim, seed = 12345)
head(results)
aggregate(results)
tv <- mean(eusilcP$eqIncome)  # true population mean
plot(results) + geom_hline(yintercept=tv)



#### model-based simulation

## function for generating data
rgnorm <- function(n, means) {
    group <- sample(1:2, n, replace=TRUE)
    data.frame(group=group, value=rnorm(n) + means[group])
}

## control objects for data generation and contamination
means <- c(0, 0.25)
dc <- DataControl(size = 500, distribution = rgnorm, 
    dots = list(means = means))
cc <- CCARContControl(target = "value", 
    epsilon = 0.02, dots = list(mean = 15))

## function for simulation runs
sim <- function(x) {
    c(mean = mean(x$value), 
        trimmed = mean(x$value, trim = 0.02), 
        median = median(x$value))
}

## run simulation and explore results
results <- runSimulation(dc, nrep = 50, contControl = cc, 
    design = "group", fun = sim, seed = 12345)
head(results)
aggregate(results)
tv <- data.frame(mean=means, group=1:2)
plot(results) + geom_hline(aes(yintercept=mean), data=tv)
}
\keyword{design}
\keyword{methods}
