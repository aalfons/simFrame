\name{runSimulation}
\docType{methods}
\alias{runSimulation}
\alias{runSimulation-methods}
\alias{runSimulation,ANY,ANY,ANY,missing-method}
\alias{runSimulation,data.frame,ANY,ANY,SimControl-method}
\alias{runSimulation,data.frame,SampleSetup,ANY,SimControl-method}
\alias{runSimulation,data.frame,VirtualSampleControl,ANY,SimControl-method}
\alias{runSimulation,VirtualDataControl,ANY,ANY,SimControl-method}
\alias{runSimulation,VirtualDataControl,VirtualSampleControl,ANY,SimControl-method}

\title{Run a simulation experiment}
\description{
Generic function for running a simulation experiment.
}
\usage{
runSimulation(x, setup = NULL, nrep = 1, control, 
              contControl = NULL, NAControl = NULL, 
              design = character(), fun, ..., seed, 
              ncores = 1, cl = NULL)
}
\arguments{
  \item{x}{a data frame (for design-based simulation or simulation based on 
    real data) or a control object for data generation inheriting from 
    \code{"\linkS4class{VirtualDataControl}"} (for model-based simulation or 
    mixed simulation designs).}
  \item{setup}{an object of class \code{"\linkS4class{SampleSetup}"} containing 
    previously set up samples (for design-based simulation), or a control class 
    for setting up samples inheriting from 
    \code{"\linkS4class{VirtualSampleControl}"} (for design-based simulation or 
    mixed simulation designs).}
  \item{nrep}{a non-negative integer giving the number of repetitions of the 
    simulation experiment (for model-based simulation, mixed simulation designs 
    or simulation based on real data).}
  \item{control}{a control object of class \code{"\linkS4class{SimControl}"}.}    
  \item{contControl}{an optional object of a class inheriting from 
    \code{"\linkS4class{VirtualContControl}"}, controlling contamination in the 
    simulation experiment.}
  \item{NAControl}{an optional object of a class inheriting from 
    \code{"\linkS4class{VirtualNAControl}"}, controlling the insertion of 
    missing values in the simulation experiment.}
  \item{design}{an optional character vector specifying variables (columns) to 
    be used for splitting the data into domains.  The simulations, including 
    contamination and the insertion of missing values, are then performed on 
    every domain.}
  \item{fun}{a function to be applied in each simulation run.}
  \item{\dots}{additional arguments to be passed to \code{fun}.}
  \item{seed}{an integer to be used as initial seed of the random number 
    generator (see \code{\link{.Random.seed}}).  In case of parallel computing, 
    random number streams are used and the seed is set via 
    \code{\link[parallel:RngStream]{clusterSetRNGStream}}.  If not supplied, 
    the seed will be based on the current date and time.}
  \item{ncores}{a positive integer giving the number of processor cores to be 
    used for parallel computing (the default is 1 for no parallelization).  If 
    this is set to \code{NA}, all available processor cores are used.}
  \item{cl}{a \pkg{parallel} cluster for parallel computing as generated by 
    \code{\link[parallel]{makeCluster}}.  If supplied, this is preferred over 
    \code{ncores}.}
}
\details{
  For convenience, the slots of \code{control} may be supplied as arguments.
  
  There are some requirements for slot \code{fun} of the control object 
  \code{control}.  Most importantly, the function must return a numeric 
  vector.  A data frame is passed to \code{fun} in every simulation run.  The 
  corresponding argument must be called \code{x}.  If comparisons with the 
  original data need to be made, e.g., for evaluating the quality of imputation 
  methods, the function should have an argument called \code{orig}.  If 
  different domains are used in the simulation, the indices of the current 
  domain can be passed to the function via an argument called \code{domain}.

  In every simulation run, \code{fun} is evaluated using \code{try}.  Hence 
  no results are lost if computations fail in any of the simulation runs.
}
\value{
  An object of class \code{"\linkS4class{SimResults}"}.
}
\section{Methods}{
  \describe{
  \item{\code{signature(x = "ANY", setup = "ANY", nrep = "ANY", 
    control = "missing")}}{convenience wrapper that allows the slots of 
    \code{control} to be supplied as arguments}
  \item{\code{signature(x = "data.frame", setup = "ANY", nrep = "ANY", 
    control = "SimControl")}}{run a simulation experiment based on real data.}
  \item{\code{signature(x = "data.frame", setup = "SampleSetup", nrep = "ANY", 
    control = "SimControl")}}{run a design-based simulation experiment with 
    previously set up samples.}
  \item{\code{signature(x = "data.frame", setup = "VirtualSampleControl", 
    nrep = "ANY", control = "SimControl")}}{run a design-based simulation 
    experiment.}
  \item{\code{signature(x = "VirtualDataControl", setup = "ANY", nrep = "ANY", 
    control = "SimControl")}}{run a model-based simulation experiment.}
  \item{\code{signature(x = "VirtualDataControl", 
    setup = "VirtualSampleControl", nrep = "ANY", control = "SimControl")}}{run 
    a simulation experiment using a mixed simulation design.}
  }
}
\author{Andreas Alfons}
\references{
Alfons, A., Templ, M. and Filzmoser, P. (2010) An Object-Oriented Framework for 
Statistical Simulation: The \R Package \pkg{simFrame}. \emph{Journal of 
Statistical Software}, \bold{37}(3), 1--36. URL 
\url{http://www.jstatsoft.org/v37/i03/}.
}
\seealso{
  \code{"\linkS4class{SimControl}"}, \code{"\linkS4class{SimResults}"}, 
  \code{\link{simPlot}}
}
\examples{
#### design-based simulation
data("eusilcP")  # load data

## control objects for sampling and contamination
sc <- SampleControl(size = 100, k = 50, seed = 12345)
cc <- ContControl(target = "eqIncome", epsilon = 0.02, 
    fun = function(x) x * 10, type = "CAR")

## function for simulation runs
sim <- function(x) {
    c(mean = mean(x$eqIncome), trimmed = mean(x$eqIncome, 0.05))
}

## run simulation and explore results
results <- runSimulation(eusilcP, sc, contControl = cc, 
    fun = sim, seed = 12345)
head(results)
aggregate(results)
tv <- mean(eusilcP$eqIncome)  # true population mean
plot(results) + geom_hline(yintercept=tv)



#### model-based simulation

## function for generating data
rgnorm <- function(n, means) {
    group <- sample(1:2, n, replace=TRUE)
    data.frame(group=group, value=rnorm(n) + means[group])
}

## control objects for data generation and contamination
means <- c(0, 0.25)
dc <- DataControl(size = 100, fun = rgnorm, 
    dots = list(means = means))
cc <- ContControl(target = "value", epsilon = 0.02, 
    dots = list(mean = 10), type = "CCAR")

## function for simulation runs
sim <- function(x) {
    c(mean = mean(x$value), 
        trimmed = mean(x$value, trim = 0.05), 
        median = median(x$value))
}

## run simulation and explore results
results <- runSimulation(dc, nrep = 50, contControl = cc, 
    design = "group", fun = sim, seed = 12345)
head(results)
aggregate(results)
tv <- data.frame(mean=means, group=1:2)
plot(results) + geom_hline(aes(yintercept=mean), data=tv)
}
\keyword{design}
\keyword{methods}
